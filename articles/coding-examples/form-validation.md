<!-- Filename: J4.x:Joomla_4_Tips_and_Tricks:_Form_Validation_Basics / Display title: Проверка форм -->

## Введение

Joomla имеет сценарий валидации на стороне клиента, который может использоваться и расширяться любым компонентом. В этой статье описывается, как он работает и как его использовать. Существует четыре стандартных валидатора для типов полей: имя пользователя, пароль, числовое и электронная почта. Также имеется валидатор шаблонов общего назначения и валидатор обязательного поля.

Обратите внимание, что современные браузеры также предоставляют проверку форм по умолчанию. Проверка браузера может быть отключена путем добавления novalidate в тег формы.

## Как вызвать проверку

В верхней части файла edit.php, содержащего код генерации формы, включите вызов для загрузки файла javascript-валидатора:

```php
/** @var Joomla\CMS\WebAsset\WebAssetManager $wa */
$wa = $this->document->getWebAssetManager();
$wa->useScript('keepalive')
    ->useScript('form.validate');
```

в теге form убедитесь, что включен класс="form-validate". Этот пример из формы редактирования пользователя:

```html
<form action="<?php echo Route::_('index.php?option=com_users&layout=edit&id=' . (int) $this->item->id); ?>"
    method="post" name="adminForm" id="user-form"
    enctype="multipart/form-data"
    aria-label="<?php echo Text::_('COM_USERS_USER_FORM_' . ( (int) $this->item->id === 0 ? 'NEW' : 'EDIT'), true); ?>"
    class="form-validate">
```

В файле формы XML включите инструкции, которые вызывают проверку отдельных полей. Этот пример относится к полю электронной почты пользователя:

```xml
        <field
            name="email"
            type="email"
            label="JGLOBAL_EMAIL"
            required="true"
            size="30"
            validate="email"
            validDomains="com_users.domains"
        />
```

## Выражения проверки

Этот раздел предназначен для того, чтобы дать небольшое понимание выражений валидации, чтобы помочь объяснить их использование. Все они включены в код validator.js.

### Имя пользователя

```php
this.setHandler('username', value => {
      const regex = new RegExp('[<|>|"|\'|%|;|(|)|&]', 'i');
      return !regex.test(value);
    });
```

Здесь выражение ищет наличие любого из альтернативных символов внутри класса символов [] и возвращает false (не является допустимым), если какой-либо из них найден.

### Пароль

```pnp
this.setHandler('password', value => {
      const regex = /^\S[\S ]{2,98}\S$/;
      return regex.test(value);
    });
```

Здесь выражение ищет начальный символ, который не является пробелом, за которым следует от 2 до 98 символов, которые либо не являются пробелами, либо пробелами, и заканчивается символом, который не является пробелом. Joomla имеет более сложный проверяющий паролей, который обеспечивает смесь типов символов и минимальную длину.

### Электронная почта

```php
this.setHandler('email', value => {
      const newValue = punycode.toASCII(value);
      const regex = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;
      return regex.test(newValue);
    }); // Attach all forms with a class 'form-validate'
```

Здесь регулярное выражение принимает любую строку, которая начинается с одного или более символов из класса символов в [], за которым следует @, затем один или более символов из второго класса символов в [], затем ноль или более точек, за которыми следует один или более символов из третьей группы класса символов, и заканчивается одним из групп после @.

Хотя это технически правильно, этот валидатор позволяет использовать некоторые довольно глупые адреса электронной почты, такие как !@me - возможно, вы захотите создать более строгий шаблон.

### Числовой

```php
this.setHandler('numeric', value => {
      const regex = /^(\d|-)?(\d|,)*\.?\d*$/;
      return regex.test(value);
    });
```

Здесь значение должно начинаться с цифры или знака минус, ноль или один раз, после чего должна следовать цифра или запятая ноль или более раз, за которыми следует точка ноль или один раз, заканчиваясь цифрой ноль или более раз. Таким образом, это будет соответствовать 3.142 или -10 или 100,000.0 и так далее. Фактическое число должно соответствовать типу поля в базе данных. Выражение не будет соответствовать числам с экспонентами, поэтому 10e2 будет отклонено.

### Узор

Предположим, вы хотите, чтобы поле ввода было положительным целым числом. Вы можете использовать свой собственный шаблон, размещенный в файле xml формы:

```xml
        <field
            name="number"
            type="text"
            label="COM_MYCOMPONENT_CAMP_NUMBER_LABEL"
            description="COM_MYCOMPONENT_CAMP_NUMBER_DESC"
            class="w-auto"
            required="true"
            pattern="\d+"
        />
```

Здесь шаблон допускает одну или более цифр. Поэтому -1 будет недействительным, как и 3.142.

### Обязательно

Убедитесь, что в спецификации поля указано required="true", иначе метка формы не будет содержать обычно используемый * маркер, указывающий на обязательные поля. Включение required в класс недостаточно для проверки.

*Переведено openai.com*

